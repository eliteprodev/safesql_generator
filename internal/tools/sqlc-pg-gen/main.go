package main

import (
	"bytes"
	"context"
	"fmt"
	"go/format"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	pgx "github.com/jackc/pgx/v4"
)

// https://stackoverflow.com/questions/25308765/postgresql-how-can-i-inspect-which-arguments-to-a-procedure-have-a-default-valu
const catalogFuncs = `
SELECT p.proname as name,
  format_type(p.prorettype, NULL),
  array(select format_type(unnest(p.proargtypes), NULL)),
  p.proargnames,
  p.proargnames[p.pronargs-p.pronargdefaults+1:p.pronargs],
  p.proargmodes::text[]
FROM pg_catalog.pg_proc p
LEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace
WHERE n.nspname OPERATOR(pg_catalog.~) '^(pg_catalog)$'
  AND pg_function_is_visible(p.oid)
-- simply order all columns to keep subsequent runs stable
ORDER BY 1, 2, 3, 4, 5;
`

// https://dba.stackexchange.com/questions/255412/how-to-select-functions-that-belong-in-a-given-extension-in-postgresql
//
// Extension functions are added to the public schema
const extensionFuncs = `
WITH extension_funcs AS (
  SELECT p.oid
  FROM pg_catalog.pg_extension AS e
      INNER JOIN pg_catalog.pg_depend AS d ON (d.refobjid = e.oid)
      INNER JOIN pg_catalog.pg_proc AS p ON (p.oid = d.objid)
      INNER JOIN pg_catalog.pg_namespace AS ne ON (ne.oid = e.extnamespace)
      INNER JOIN pg_catalog.pg_namespace AS np ON (np.oid = p.pronamespace)
  WHERE d.deptype = 'e' AND e.extname = $1
)
SELECT p.proname as name,
  format_type(p.prorettype, NULL),
  array(select format_type(unnest(p.proargtypes), NULL)),
  p.proargnames,
  p.proargnames[p.pronargs-p.pronargdefaults+1:p.pronargs],
  p.proargmodes::text[]
FROM pg_catalog.pg_proc p
JOIN extension_funcs ef ON ef.oid = p.oid
WHERE pg_function_is_visible(p.oid)
-- simply order all columns to keep subsequent runs stable
ORDER BY 1, 2, 3, 4, 5;
`

const catalogTmpl = `
// Code generated by sqlc-pg-gen. DO NOT EDIT.

package {{.Pkg}}

import (
	"github.com/kyleconroy/sqlc/internal/sql/ast"
	"github.com/kyleconroy/sqlc/internal/sql/catalog"
)

func {{.Name}}() *catalog.Schema {
	s := &catalog.Schema{Name: "pg_catalog"}
	s.Funcs = []*catalog.Function{
	    {{- range .Procs}}
		{
			Name: "{{.Name}}",
			Args: []*catalog.Argument{
				{{range .Args}}{
				{{- if .Name}}
				Name: "{{.Name}}",
				{{- end}}
				{{- if .HasDefault}}
				HasDefault: true,
				{{- end}}
				Type: &ast.TypeName{Name: "{{.TypeName}}"},
				{{- if ne .Mode "i" }}
				Mode: {{ .GoMode }},
				{{- end}}
				},
				{{end}}
			},
			ReturnType: &ast.TypeName{Name: "{{.ReturnTypeName}}"},
		},
		{{- end}}
	}
	return s
}
`

const loaderFuncTmpl = `
// Code generated by sqlc-pg-gen. DO NOT EDIT.

package postgresql

import (
	"github.com/kyleconroy/sqlc/internal/engine/postgresql/contrib"
	"github.com/kyleconroy/sqlc/internal/sql/catalog"
)

func loadExtension(name string) *catalog.Schema {
	switch name {
	{{- range .}}
	case "{{.Name}}":
		return contrib.{{.Func}}()
	{{- end}}
	}
	return nil
}
`

type tmplCtx struct {
	Pkg   string
	Name  string
	Procs []Proc
}

func main() {
	if err := run(context.Background()); err != nil {
		log.Fatal(err)
	}
}

type Proc struct {
	Name       string
	ReturnType string
	ArgTypes   []string
	ArgNames   []string
	HasDefault []string
	ArgModes   []string
}

func (p *Proc) ReturnTypeName() string {
	return clean(p.ReturnType)
}

func (p *Proc) Args() []Arg {
	var args []Arg
	defaults := map[string]bool{}
	for _, name := range p.HasDefault {
		defaults[name] = true
	}

	for i, argType := range p.ArgTypes {
		mode := "i"
		name := ""
		if i < len(p.ArgModes) {
			mode = p.ArgModes[i]
		}
		if i < len(p.ArgNames) {
			name = p.ArgNames[i]
		}

		args = append(args, Arg{
			Name:       name,
			Type:       argType,
			Mode:       mode,
			HasDefault: defaults[name],
		})
	}

	// Some manual changes until https://github.com/kyleconroy/sqlc/pull/1748
	// can be completely implmented
	if p.Name == "mode" {
		return nil
	}

	if p.Name == "percentile_cont" && len(args) == 2 {
		args = args[:1]
	}

	if p.Name == "percentile_disc" && len(args) == 2 {
		args = args[:1]
	}

	return args
}

type Arg struct {
	Name       string
	Mode       string
	Type       string
	HasDefault bool
}

func (a *Arg) TypeName() string {
	return clean(a.Type)
}

// GoMode returns Go's representation of the arguemnt's mode
func (a *Arg) GoMode() string {
	switch a.Mode {
	case "", "i":
		return "ast.FuncParamIn"
	case "o":
		return "ast.FuncParamOut"
	case "b":
		return "ast.FuncParamInOut"
	case "v":
		return "ast.FuncParamVariadic"
	case "t":
		return "ast.FuncParamTable"
	}

	return ""
}

func clean(arg string) string {
	arg = strings.TrimSpace(arg)
	arg = strings.Replace(arg, "\"any\"", "any", -1)
	arg = strings.Replace(arg, "\"char\"", "char", -1)
	arg = strings.Replace(arg, "\"timestamp\"", "char", -1)
	return arg
}

func scanProcs(rows pgx.Rows) ([]Proc, error) {
	defer rows.Close()
	// Iterate through the result set
	var procs []Proc
	for rows.Next() {
		var p Proc
		err := rows.Scan(
			&p.Name,
			&p.ReturnType,
			&p.ArgTypes,
			&p.ArgNames,
			&p.HasDefault,
			&p.ArgModes,
		)
		if err != nil {
			return nil, err
		}

		// TODO: Filter these out in SQL
		if strings.HasPrefix(p.ReturnType, "SETOF") {
			continue
		}

		// The internal pseudo-type is used to declare functions that are meant
		// only to be called internally by the database system, and not by
		// direct invocation in an SQL query. If a function has at least one
		// internal-type argument then it cannot be called from SQL. To
		// preserve the type safety of this restriction it is important to
		// follow this coding rule: do not create any function that is declared
		// to return internal unless it has at least one internal argument
		//
		// https://www.postgresql.org/docs/current/datatype-pseudo.html
		var skip bool
		for i := range p.ArgTypes {
			if p.ArgTypes[i] == "internal" {
				skip = true
			}
		}
		if skip {
			continue
		}
		if p.ReturnType == "internal" {
			continue
		}

		procs = append(procs, p)
	}
	return procs, rows.Err()
}

func run(ctx context.Context) error {
	tmpl, err := template.New("").Parse(catalogTmpl)
	if err != nil {
		return err
	}
	conn, err := pgx.Connect(ctx, os.Getenv("DATABASE_URL"))
	if err != nil {
		return err
	}
	defer conn.Close(ctx)

	// Generate internal/engine/postgresql/pg_catalog.gen.go
	rows, err := conn.Query(ctx, catalogFuncs)
	if err != nil {
		return err
	}
	allProcs, err := scanProcs(rows)
	if err != nil {
		return err
	}

	// Preserve the legacy sort order of the end-to-end tests
	sort.SliceStable(allProcs, func(i, j int) bool {
		fnA := allProcs[i]
		fnB := allProcs[j]

		if fnA.Name == "lower" && fnB.Name == "lower" && len(fnA.ArgTypes) == 1 && fnA.ArgTypes[0] == "text" {
			return true
		}

		if fnA.Name == "generate_series" && fnB.Name == "generate_series" && len(fnA.ArgTypes) == 2 && fnA.ArgTypes[0] == "numeric" {
			return true
		}

		return false
	})

	procs := make([]Proc, 0, len(allProcs))
	for _, p := range allProcs {
		// Skip generating concat to preserve legacy behavior
		if p.Name == "concat" {
			continue
		}

		procs = append(procs, p)
	}

	out := bytes.NewBuffer([]byte{})
	if err := tmpl.Execute(out, tmplCtx{Pkg: "postgresql", Name: "genPGCatalog", Procs: procs}); err != nil {
		return err
	}
	code, err := format.Source(out.Bytes())
	if err != nil {
		return err
	}
	err = os.WriteFile(filepath.Join("internal", "engine", "postgresql", "pg_catalog.go"), code, 0644)
	if err != nil {
		return err
	}

	loaded := []extensionPair{}

	for _, extension := range extensions {
		name := strings.Replace(extension, "-", "_", -1)

		var funcName string
		for _, part := range strings.Split(name, "_") {
			funcName += strings.Title(part)
		}

		_, err := conn.Exec(ctx, fmt.Sprintf("CREATE EXTENSION IF NOT EXISTS \"%s\"", extension))
		if err != nil {
			log.Printf("error creating %s: %s", extension, err)
			continue
		}

		rows, err := conn.Query(ctx, extensionFuncs, extension)
		if err != nil {
			return err
		}
		procs, err := scanProcs(rows)
		if err != nil {
			return err
		}
		if len(procs) == 0 {
			log.Printf("no functions in %s, skipping", extension)
			continue
		}

		// Preserve the legacy sort order of the end-to-end tests
		sort.SliceStable(procs, func(i, j int) bool {
			fnA := procs[i]
			fnB := procs[j]

			if extension == "pgcrypto" {
				if fnA.Name == "digest" && fnB.Name == "digest" && len(fnA.ArgTypes) == 2 && fnA.ArgTypes[0] == "text" {
					return true
				}
			}

			return false
		})

		out := bytes.NewBuffer([]byte{})
		if err := tmpl.Execute(out, tmplCtx{Pkg: "contrib", Name: funcName, Procs: procs}); err != nil {
			return err
		}
		code, err := format.Source(out.Bytes())
		if err != nil {
			return err
		}
		err = os.WriteFile(filepath.Join("internal", "engine", "postgresql", "contrib", name+".go"), code, 0644)
		if err != nil {
			return err
		}

		loaded = append(loaded, extensionPair{Name: extension, Func: funcName})
	}

	{
		tmpl, err := template.New("").Parse(loaderFuncTmpl)
		if err != nil {
			return err
		}
		out := bytes.NewBuffer([]byte{})
		if err := tmpl.Execute(out, loaded); err != nil {
			return err
		}
		code, err := format.Source(out.Bytes())
		if err != nil {
			return err
		}
		err = os.WriteFile(filepath.Join("internal", "engine", "postgresql", "extension.go"), code, 0644)
		if err != nil {
			return err
		}
	}

	return nil
}

type extensionPair struct {
	Name string
	Func string
}

// https://www.postgresql.org/docs/current/contrib.html
var extensions = []string{
	"adminpack",
	"amcheck",
	"auth_delay",
	"auto_explain",
	"bloom",
	"btree_gin",
	"btree_gist",
	"citext",
	"cube",
	"dblink",
	"dict_int",
	"dict_xsyn",
	"earthdistance",
	"file_fdw",
	"fuzzystrmatch",
	"hstore",
	"intagg",
	"intarray",
	"isn",
	"lo",
	"ltree",
	"pageinspect",
	"passwordcheck",
	"pg_buffercache",
	"pgcrypto",
	"pg_freespacemap",
	"pg_prewarm",
	"pgrowlocks",
	"pg_stat_statements",
	"pgstattuple",
	"pg_trgm",
	"pg_visibility",
	"postgres_fdw",
	"seg",
	"sepgsql",
	"spi",
	"sslinfo",
	"tablefunc",
	"tcn",
	"test_decoding",
	"tsm_system_rows",
	"tsm_system_time",
	"unaccent",
	"uuid-ossp",
	"xml2",
}

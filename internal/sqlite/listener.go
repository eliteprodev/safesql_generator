package sqlite

import (
	"github.com/kyleconroy/sqlc/internal/sql/ast"
	"github.com/kyleconroy/sqlc/internal/sqlite/parser"
)

type listener struct {
	*parser.BaseSQLiteListener

	stmt *ast.RawStmt

	stmts []ast.Statement
}

// The Visitor code generated by Antlr doesn't currently work
//
// To make due, we mark the listener as "busy" if it's currently processing a
// node. This helps avoids scenarios where enter is called on nested
// statements.
func (l *listener) busy() bool {
	return l.stmt != nil
}

func (l *listener) EnterSql_stmt(c *parser.Sql_stmtContext) {
	l.stmt = nil
}

func (l *listener) ExitSql_stmt(c *parser.Sql_stmtContext) {
	if l.stmt != nil {
		l.stmts = append(l.stmts, ast.Statement{
			Raw: l.stmt,
		})
	}
}

func (l *listener) EnterAlter_table_stmt(c *parser.Alter_table_stmtContext) {
	if l.busy() {
		return
	}

	if newTable, ok := c.New_table_name().(*parser.New_table_nameContext); ok {
		name := newTable.Any_name().GetText()
		stmt := &ast.RenameTableStmt{
			Table:   parseTableName(c),
			NewName: &name,
		}
		l.stmt = &ast.RawStmt{Stmt: stmt}
		return
	}

	if newCol, ok := c.New_column_name().(*parser.New_column_nameContext); ok {
		name := newCol.Any_name().GetText()
		stmt := &ast.RenameColumnStmt{
			Table: parseTableName(c),
			Col: &ast.ColumnRef{
				Name: c.Column_name().GetText(),
			},
			NewName: &name,
		}
		l.stmt = &ast.RawStmt{Stmt: stmt}
		return
	}

	if def, ok := c.Column_def().(*parser.Column_defContext); ok {
		stmt := &ast.AlterTableStmt{
			Table: parseTableName(c),
			Cmds:  &ast.List{},
		}
		name := def.Column_name().GetText()
		stmt.Cmds.Items = append(stmt.Cmds.Items, &ast.AlterTableCmd{
			Name:    &name,
			Subtype: ast.AT_AddColumn,
			Def: &ast.ColumnDef{
				Colname: name,
				TypeName: &ast.TypeName{
					Name: def.Type_name().GetText(),
				},
			},
		})
		l.stmt = &ast.RawStmt{Stmt: stmt}
		return
	}

}

func (l *listener) EnterAttach_stmt(c *parser.Attach_stmtContext) {
	if l.busy() {
		return
	}

	name := c.Database_name().GetText()
	stmt := &ast.CreateSchemaStmt{
		Name: &name,
	}

	l.stmt = &ast.RawStmt{Stmt: stmt}
}

func (l *listener) EnterCreate_table_stmt(c *parser.Create_table_stmtContext) {
	if l.busy() {
		return
	}

	stmt := &ast.CreateTableStmt{
		Name:        parseTableName(c),
		IfNotExists: c.K_EXISTS() != nil,
	}

	for _, idef := range c.AllColumn_def() {
		if def, ok := idef.(*parser.Column_defContext); ok {
			stmt.Cols = append(stmt.Cols, &ast.ColumnDef{
				Colname: def.Column_name().GetText(),
				TypeName: &ast.TypeName{
					Name: def.Type_name().GetText(),
				},
			})
		}
	}

	l.stmt = &ast.RawStmt{Stmt: stmt}
}

func (l *listener) EnterDrop_table_stmt(c *parser.Drop_table_stmtContext) {
	if l.busy() {
		return
	}
	drop := &ast.DropTableStmt{
		IfExists: c.K_EXISTS() != nil,
		Tables:   []*ast.TableName{parseTableName(c)},
	}
	l.stmt = &ast.RawStmt{Stmt: drop}
}

func (l *listener) EnterFactored_select_stmt(c *parser.Factored_select_stmtContext) {
	if l.busy() {
		return
	}

	var tables []ast.Node
	var cols []ast.Node
	for _, icore := range c.AllSelect_core() {
		core, ok := icore.(*parser.Select_coreContext)
		if !ok {
			continue
		}
		for _, icol := range core.AllResult_column() {
			col, ok := icol.(*parser.Result_columnContext)
			if !ok {
				continue
			}
			iexpr := col.Expr()
			if iexpr == nil {
				continue
			}
			expr, ok := iexpr.(*parser.ExprContext)
			if !ok {
				continue
			}
			cols = append(cols, &ast.ResTarget{
				Val: &ast.ColumnRef{
					Name: expr.Column_name().GetText(),
				},
			})
		}
		for _, ifrom := range core.AllTable_or_subquery() {
			from, ok := ifrom.(*parser.Table_or_subqueryContext)
			if !ok {
				continue
			}
			name := ast.TableName{
				Name: from.Table_name().GetText(),
			}
			if from.Schema_name() != nil {
				name.Schema = from.Schema_name().GetText()
			}
			tables = append(tables, &name)
		}
	}

	sel := &ast.SelectStmt{
		From:   &ast.List{Items: tables},
		Fields: &ast.List{Items: cols},
	}
	l.stmt = &ast.RawStmt{Stmt: sel}
}

var _ parser.SQLiteListener = (*listener)(nil)

// Code generated by sqlc. DO NOT EDIT.
// source: query.sql

package querytest

import (
	"context"
	"database/sql"
)

const getUserByID = `-- name: GetUserByID :one
select first_name, id, last_name from users where id = ?
`

type GetUserByIDRow struct {
	FirstName string
	ID        int
	LastName  sql.NullString
}

func (q *Queries) GetUserByID(ctx context.Context, targetID int) (GetUserByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, targetID)
	var i GetUserByIDRow
	err := row.Scan(&i.FirstName, &i.ID, &i.LastName)
	return i, err
}

const insertNewUser = `-- name: InsertNewUser :exec
insert into users(first_name, last_name) values (?, ?)
`

type InsertNewUserParams struct {
	FirstName    string
	UserLastName sql.NullString
}

func (q *Queries) InsertNewUser(ctx context.Context, arg InsertNewUserParams) error {
	_, err := q.db.ExecContext(ctx, insertNewUser, arg.FirstName, arg.UserLastName)
	return err
}

const limitSQLCArg = `-- name: LimitSQLCArg :many
select first_name, id from users limit ?
`

type LimitSQLCArgRow struct {
	FirstName string
	ID        int
}

func (q *Queries) LimitSQLCArg(ctx context.Context, UsersLimit uint32) ([]LimitSQLCArgRow, error) {
	rows, err := q.db.QueryContext(ctx, limitSQLCArg, UsersLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LimitSQLCArgRow
	for rows.Next() {
		var i LimitSQLCArgRow
		if err := rows.Scan(&i.FirstName, &i.ID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserOrders = `-- name: ListUserOrders :many
select users.id, users.first_name, orders.price from orders left join users on orders.user_id = users.id where orders.price > ?
`

type ListUserOrdersRow struct {
	ID        sql.NullInt64
	FirstName sql.NullString
	Price     float64
}

func (q *Queries) ListUserOrders(ctx context.Context, minPrice float64) ([]ListUserOrdersRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserOrders, minPrice)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserOrdersRow
	for rows.Next() {
		var i ListUserOrdersRow
		if err := rows.Scan(&i.ID, &i.FirstName, &i.Price); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserParenExpr = `-- name: ListUserParenExpr :many
select id, first_name, last_name, age, job_status from users where (job_status = 'APPLIED' or job_status = 'PENDING') and id > ? order by id asc limit ?
`

type ListUserParenExprParams struct {
	LastID int
	Limit  uint32
}

func (q *Queries) ListUserParenExpr(ctx context.Context, arg ListUserParenExprParams) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUserParenExpr, arg.LastID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.Age,
			&i.JobStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByFamily = `-- name: ListUsersByFamily :many
select first_name, last_name from users where age < ? and last_name = ?
`

type ListUsersByFamilyParams struct {
	MaxAge   int
	InFamily sql.NullString
}

type ListUsersByFamilyRow struct {
	FirstName string
	LastName  sql.NullString
}

func (q *Queries) ListUsersByFamily(ctx context.Context, arg ListUsersByFamilyParams) ([]ListUsersByFamilyRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersByFamily, arg.MaxAge, arg.InFamily)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersByFamilyRow
	for rows.Next() {
		var i ListUsersByFamilyRow
		if err := rows.Scan(&i.FirstName, &i.LastName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByID = `-- name: ListUsersByID :many
select first_name, id, last_name from users where id < ?
`

type ListUsersByIDRow struct {
	FirstName string
	ID        int
	LastName  sql.NullString
}

func (q *Queries) ListUsersByID(ctx context.Context, id int) ([]ListUsersByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersByID, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersByIDRow
	for rows.Next() {
		var i ListUsersByIDRow
		if err := rows.Scan(&i.FirstName, &i.ID, &i.LastName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersWithLimit = `-- name: ListUsersWithLimit :many
select first_name, last_name from users limit ?
`

type ListUsersWithLimitRow struct {
	FirstName string
	LastName  sql.NullString
}

func (q *Queries) ListUsersWithLimit(ctx context.Context, limit uint32) ([]ListUsersWithLimitRow, error) {
	rows, err := q.db.QueryContext(ctx, listUsersWithLimit, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUsersWithLimitRow
	for rows.Next() {
		var i ListUsersWithLimitRow
		if err := rows.Scan(&i.FirstName, &i.LastName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

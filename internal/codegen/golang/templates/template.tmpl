{{define "dbFile"}}// Code generated by sqlc. DO NOT EDIT.

package {{.Package}}

import (
	{{range imports .SourceName}}
	{{range .}}{{.}}
	{{end}}
	{{end}}
)

{{template "dbCode" . }}
{{end}}

{{define "dbCode"}}

{{if eq .Driver "pgx/v4"}}
	{{- template "dbCodeTemplatePgx" .}}
{{else}}
	{{- template "dbCodeTemplateStd" .}}
{{end}}

{{end}}

{{define "interfaceFile"}}// Code generated by sqlc. DO NOT EDIT.

package {{.Package}}

import (
	{{range imports .SourceName}}
	{{range .}}{{.}}
	{{end}}
	{{end}}
)

{{template "interfaceCode" . }}
{{end}}

{{define "interfaceCode"}}
	{{if eq .Driver "pgx/v4"}}
		{{- template "interfaceCodePgx" .}}
	{{else}}
		{{- template "interfaceCodeStd" .}}
	{{end}}
{{end}}

{{define "modelsFile"}}// Code generated by sqlc. DO NOT EDIT.

package {{.Package}}

import (
	{{range imports .SourceName}}
	{{range .}}{{.}}
	{{end}}
	{{end}}
)

{{template "modelsCode" . }}
{{end}}

{{define "modelsCode"}}
{{range .Enums}}
{{if .Comment}}{{comment .Comment}}{{end}}
type {{.Name}} string

const (
	{{- range .Constants}}
	{{.Name}} {{.Type}} = "{{.Value}}"
	{{- end}}
)

func (e *{{.Name}}) Scan(src interface{}) error {
	switch s := src.(type) {
	case []byte:
		*e = {{.Name}}(s)
	case string:
		*e = {{.Name}}(s)
	default:
		return fmt.Errorf("unsupported scan type for {{.Name}}: %T", src)
	}
	return nil
}
{{end}}

{{range .Structs}}
{{if .Comment}}{{comment .Comment}}{{end}}
type {{.Name}} struct { {{- range .Fields}}
  {{- if .Comment}}
  {{comment .Comment}}{{else}}
  {{- end}}
  {{.Name}} {{.Type}} {{if or ($.EmitJSONTags) ($.EmitDBTags)}}{{$.Q}}{{.Tag}}{{$.Q}}{{end}}
  {{- end}}
}
{{end}}
{{end}}

{{define "queryFile"}}// Code generated by sqlc. DO NOT EDIT.
// source: {{.SourceName}}

package {{.Package}}

import (
	{{range imports .SourceName}}
	{{range .}}{{.}}
	{{end}}
	{{end}}
)

{{template "queryCode" . }}
{{end}}

{{define "queryCode"}}
{{if eq .Driver "pgx/v4"}}
    {{- template "queryCodePgx" .}}
{{else}}
    {{- template "queryCodeStd" .}}
{{end}}
{{end}}
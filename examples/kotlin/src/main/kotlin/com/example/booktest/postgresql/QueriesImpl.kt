// Code generated by sqlc. DO NOT EDIT.

package com.example.booktest.postgresql

import java.sql.Connection
import java.sql.SQLException
import java.sql.Types
import java.time.OffsetDateTime

const val booksByTags = """-- name: booksByTags :many
SELECT 
  book_id,
  title,
  name,
  isbn,
  tags
FROM books
LEFT JOIN authors ON books.author_id = authors.author_id
WHERE tags && ?::varchar[]
"""

data class BooksByTagsRow (
  val bookId: Int,
  val title: String,
  val name: String,
  val isbn: String,
  val tags: List<String>
)

const val booksByTitleYear = """-- name: booksByTitleYear :many
SELECT book_id, author_id, isbn, booktype, title, year, available, tags FROM books
WHERE title = ? AND year = ?
"""

data class BooksByTitleYearParams (
  val title: String,
  val year: Int
)

const val createAuthor = """-- name: createAuthor :one
INSERT INTO authors (name) VALUES (?)
RETURNING author_id, name
"""

const val createBook = """-- name: createBook :one
INSERT INTO books (
    author_id,
    isbn,
    booktype,
    title,
    year,
    available,
    tags
) VALUES (
    ?,
    ?,
    ?,
    ?,
    ?,
    ?,
    ?
)
RETURNING book_id, author_id, isbn, booktype, title, year, available, tags
"""

data class CreateBookParams (
  val authorId: Int,
  val isbn: String,
  val booktype: BookType,
  val title: String,
  val year: Int,
  val available: OffsetDateTime,
  val tags: List<String>
)

const val deleteBook = """-- name: deleteBook :exec
DELETE FROM books
WHERE book_id = ?
"""

const val getAuthor = """-- name: getAuthor :one
SELECT author_id, name FROM authors
WHERE author_id = ?
"""

const val getBook = """-- name: getBook :one
SELECT book_id, author_id, isbn, booktype, title, year, available, tags FROM books
WHERE book_id = ?
"""

const val updateBook = """-- name: updateBook :exec
UPDATE books
SET title = ?, tags = ?
WHERE book_id = ?
"""

data class UpdateBookParams (
  val title: String,
  val tags: List<String>,
  val bookId: Int
)

const val updateBookISBN = """-- name: updateBookISBN :exec
UPDATE books
SET title = ?, tags = ?, isbn = ?
WHERE book_id = ?
"""

data class UpdateBookISBNParams (
  val title: String,
  val tags: List<String>,
  val isbn: String,
  val bookId: Int
)

class QueriesImpl(private val conn: Connection) {

  @Throws(SQLException::class)
  fun booksByTags(dollar_1: List<String>): List<BooksByTagsRow> {
    val stmt = conn.prepareStatement(booksByTags)
    stmt.setArray(1, conn.createArrayOf("pg_catalog.varchar", dollar_1.toTypedArray()))

    return stmt.executeQuery().use { results ->
      val ret = mutableListOf<BooksByTagsRow>()
      while (results.next()) {
          ret.add(BooksByTagsRow(
      results.getInt(1),
      results.getString(2),
      results.getString(3),
      results.getString(4),
      (results.getArray(5).array as Array<String>).toList()
    ))
      }
      ret
    }
  }

  @Throws(SQLException::class)
  fun booksByTitleYear(arg: BooksByTitleYearParams): List<Book> {
    val stmt = conn.prepareStatement(booksByTitleYear)
    stmt.setString(1, arg.title)
    stmt.setInt(2, arg.year)

    return stmt.executeQuery().use { results ->
      val ret = mutableListOf<Book>()
      while (results.next()) {
          ret.add(Book(
      results.getInt(1),
      results.getInt(2),
      results.getString(3),
      BookType.lookup(results.getString(4))!!,
      results.getString(5),
      results.getInt(6),
      results.getObject(7, OffsetDateTime::class.java),
      (results.getArray(8).array as Array<String>).toList()
    ))
      }
      ret
    }
  }

  @Throws(SQLException::class)
  fun createAuthor(name: String): Author {
    val stmt = conn.prepareStatement(createAuthor)
    stmt.setString(1, name)

    return stmt.executeQuery().use { results ->
      if (!results.next()) {
        throw SQLException("no rows in result set")
      }
      val ret = Author(
      results.getInt(1),
      results.getString(2)
    )
      if (results.next()) {
          throw SQLException("expected one row in result set, but got many")
      }
      ret
    }
  }

  @Throws(SQLException::class)
  fun createBook(arg: CreateBookParams): Book {
    val stmt = conn.prepareStatement(createBook)
    stmt.setInt(1, arg.authorId)
    stmt.setString(2, arg.isbn)
    stmt.setObject(3, arg.booktype.value, Types.OTHER)
    stmt.setString(4, arg.title)
    stmt.setInt(5, arg.year)
    stmt.setObject(6, arg.available)
    stmt.setArray(7, conn.createArrayOf("pg_catalog.varchar", arg.tags.toTypedArray()))

    return stmt.executeQuery().use { results ->
      if (!results.next()) {
        throw SQLException("no rows in result set")
      }
      val ret = Book(
      results.getInt(1),
      results.getInt(2),
      results.getString(3),
      BookType.lookup(results.getString(4))!!,
      results.getString(5),
      results.getInt(6),
      results.getObject(7, OffsetDateTime::class.java),
      (results.getArray(8).array as Array<String>).toList()
    )
      if (results.next()) {
          throw SQLException("expected one row in result set, but got many")
      }
      ret
    }
  }

  @Throws(SQLException::class)
  fun deleteBook(bookId: Int) {
    val stmt = conn.prepareStatement(deleteBook)
    stmt.setInt(1, bookId)

    stmt.execute()
    stmt.close()
  }

  @Throws(SQLException::class)
  fun getAuthor(authorId: Int): Author {
    val stmt = conn.prepareStatement(getAuthor)
    stmt.setInt(1, authorId)

    return stmt.executeQuery().use { results ->
      if (!results.next()) {
        throw SQLException("no rows in result set")
      }
      val ret = Author(
      results.getInt(1),
      results.getString(2)
    )
      if (results.next()) {
          throw SQLException("expected one row in result set, but got many")
      }
      ret
    }
  }

  @Throws(SQLException::class)
  fun getBook(bookId: Int): Book {
    val stmt = conn.prepareStatement(getBook)
    stmt.setInt(1, bookId)

    return stmt.executeQuery().use { results ->
      if (!results.next()) {
        throw SQLException("no rows in result set")
      }
      val ret = Book(
      results.getInt(1),
      results.getInt(2),
      results.getString(3),
      BookType.lookup(results.getString(4))!!,
      results.getString(5),
      results.getInt(6),
      results.getObject(7, OffsetDateTime::class.java),
      (results.getArray(8).array as Array<String>).toList()
    )
      if (results.next()) {
          throw SQLException("expected one row in result set, but got many")
      }
      ret
    }
  }

  @Throws(SQLException::class)
  fun updateBook(arg: UpdateBookParams) {
    val stmt = conn.prepareStatement(updateBook)
    stmt.setString(1, arg.title)
    stmt.setArray(2, conn.createArrayOf("pg_catalog.varchar", arg.tags.toTypedArray()))
    stmt.setInt(3, arg.bookId)

    stmt.execute()
    stmt.close()
  }

  @Throws(SQLException::class)
  fun updateBookISBN(arg: UpdateBookISBNParams) {
    val stmt = conn.prepareStatement(updateBookISBN)
    stmt.setString(1, arg.title)
    stmt.setArray(2, conn.createArrayOf("pg_catalog.varchar", arg.tags.toTypedArray()))
    stmt.setString(3, arg.isbn)
    stmt.setInt(4, arg.bookId)

    stmt.execute()
    stmt.close()
  }

}


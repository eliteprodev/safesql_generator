# Code generated by sqlc. DO NOT EDIT.
from typing import AsyncIterator, Awaitable, Iterator, List, Optional, overload
import datetime

import pydantic
import sqlc_runtime as sqlc

from ondeck import models


CREATE_VENUE = """-- name: create_venue :one
INSERT INTO venue (
    slug,
    name,
    city,
    created_at,
    spotify_playlist,
    status,
    statuses,
    tags
) VALUES (
    $1,
    $2,
    $3,
    NOW(),
    $4,
    $5,
    $6,
    $7
) RETURNING id
"""


class CreateVenueParams(pydantic.BaseModel):
    slug: str
    name: str
    city: str
    spotify_playlist: str
    status: models.Status
    statuses: Optional[List[models.Status]]
    tags: Optional[List[str]]


DELETE_VENUE = """-- name: delete_venue :exec
DELETE FROM venue
WHERE slug = $1 AND slug = $1
"""


GET_VENUE = """-- name: get_venue :one
SELECT id, status, statuses, slug, name, city, spotify_playlist, songkick_id, tags, created_at
FROM venue
WHERE slug = $1 AND city = $2
"""


class GetVenueRow(pydantic.BaseModel):
    id: int
    status: models.Status
    statuses: Optional[List[models.Status]]
    slug: str
    name: str
    city: str
    spotify_playlist: str
    songkick_id: Optional[str]
    tags: Optional[List[str]]
    created_at: datetime.datetime


LIST_VENUES = """-- name: list_venues :many
SELECT id, status, statuses, slug, name, city, spotify_playlist, songkick_id, tags, created_at
FROM venue
WHERE city = $1
ORDER BY name
"""


class ListVenuesRow(pydantic.BaseModel):
    id: int
    status: models.Status
    statuses: Optional[List[models.Status]]
    slug: str
    name: str
    city: str
    spotify_playlist: str
    songkick_id: Optional[str]
    tags: Optional[List[str]]
    created_at: datetime.datetime


UPDATE_VENUE_NAME = """-- name: update_venue_name :one
UPDATE venue
SET name = $2
WHERE slug = $1
RETURNING id
"""


VENUE_COUNT_BY_CITY = """-- name: venue_count_by_city :many
SELECT
    city,
    count(*)
FROM venue
GROUP BY 1
ORDER BY 1
"""


class VenueCountByCityRow(pydantic.BaseModel):
    city: str
    count: int


@overload
def create_venue(conn: sqlc.Connection, arg: CreateVenueParams) -> Optional[int]:
    pass


@overload
def create_venue(conn: sqlc.AsyncConnection, arg: CreateVenueParams) -> Awaitable[Optional[int]]:
    pass


def create_venue(conn: sqlc.GenericConnection, arg: CreateVenueParams) -> sqlc.ReturnType[Optional[int]]:
    return conn.execute_one(CREATE_VENUE, arg.slug, arg.name, arg.city, arg.spotify_playlist, arg.status, arg.statuses, arg.tags)


@overload
def delete_venue(conn: sqlc.Connection, slug: str) -> None:
    pass


@overload
def delete_venue(conn: sqlc.AsyncConnection, slug: str) -> Awaitable[None]:
    pass


def delete_venue(conn: sqlc.GenericConnection, slug: str) -> sqlc.ReturnType[None]:
    return conn.execute_none(DELETE_VENUE, slug)


@overload
def get_venue(conn: sqlc.Connection, slug: str, city: str) -> Optional[GetVenueRow]:
    pass


@overload
def get_venue(conn: sqlc.AsyncConnection, slug: str, city: str) -> Awaitable[Optional[GetVenueRow]]:
    pass


def get_venue(conn: sqlc.GenericConnection, slug: str, city: str) -> sqlc.ReturnType[Optional[GetVenueRow]]:
    return conn.execute_one_model(GetVenueRow, GET_VENUE, slug, city)


@overload
def list_venues(conn: sqlc.Connection, city: str) -> Iterator[ListVenuesRow]:
    pass


@overload
def list_venues(conn: sqlc.AsyncConnection, city: str) -> AsyncIterator[ListVenuesRow]:
    pass


def list_venues(conn: sqlc.GenericConnection, city: str) -> sqlc.IteratorReturn[ListVenuesRow]:
    return conn.execute_many_model(ListVenuesRow, LIST_VENUES, city)


@overload
def update_venue_name(conn: sqlc.Connection, slug: str, name: str) -> Optional[int]:
    pass


@overload
def update_venue_name(conn: sqlc.AsyncConnection, slug: str, name: str) -> Awaitable[Optional[int]]:
    pass


def update_venue_name(conn: sqlc.GenericConnection, slug: str, name: str) -> sqlc.ReturnType[Optional[int]]:
    return conn.execute_one(UPDATE_VENUE_NAME, slug, name)


@overload
def venue_count_by_city(conn: sqlc.Connection) -> Iterator[VenueCountByCityRow]:
    pass


@overload
def venue_count_by_city(conn: sqlc.AsyncConnection) -> AsyncIterator[VenueCountByCityRow]:
    pass


def venue_count_by_city(conn: sqlc.GenericConnection) -> sqlc.IteratorReturn[VenueCountByCityRow]:
    return conn.execute_many_model(VenueCountByCityRow, VENUE_COUNT_BY_CITY)



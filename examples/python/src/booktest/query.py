# Code generated by sqlc. DO NOT EDIT.
from typing import AsyncIterator, Awaitable, Iterator, List, Optional, overload
import datetime

import pydantic
import sqlc_runtime as sqlc

from booktest import models


BOOKS_BY_TAGS = """-- name: books_by_tags :many
SELECT 
  book_id,
  title,
  name,
  isbn,
  tags
FROM books
LEFT JOIN authors ON books.author_id = authors.author_id
WHERE tags && $1::varchar[]
"""


class BooksByTagsRow(pydantic.BaseModel):
    book_id: int
    title: str
    name: str
    isbn: str
    tags: List[str]


BOOKS_BY_TITLE_YEAR = """-- name: books_by_title_year :many
SELECT book_id, author_id, isbn, book_type, title, year, available, tags FROM books
WHERE title = $1 AND year = $2
"""


class BooksByTitleYearRow(pydantic.BaseModel):
    book_id: int
    author_id: int
    isbn: str
    book_type: models.BookType
    title: str
    year: int
    available: datetime.datetime
    tags: List[str]


CREATE_AUTHOR = """-- name: create_author :one
INSERT INTO authors (name) VALUES ($1)
RETURNING author_id, name
"""


CREATE_BOOK = """-- name: create_book :one
INSERT INTO books (
    author_id,
    isbn,
    book_type,
    title,
    year,
    available,
    tags
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
)
RETURNING book_id, author_id, isbn, book_type, title, year, available, tags
"""


class CreateBookParams(pydantic.BaseModel):
    author_id: int
    isbn: str
    book_type: models.BookType
    title: str
    year: int
    available: datetime.datetime
    tags: List[str]


class CreateBookRow(pydantic.BaseModel):
    book_id: int
    author_id: int
    isbn: str
    book_type: models.BookType
    title: str
    year: int
    available: datetime.datetime
    tags: List[str]


DELETE_BOOK = """-- name: delete_book :exec
DELETE FROM books
WHERE book_id = $1
"""


GET_AUTHOR = """-- name: get_author :one
SELECT author_id, name FROM authors
WHERE author_id = $1
"""


GET_BOOK = """-- name: get_book :one
SELECT book_id, author_id, isbn, book_type, title, year, available, tags FROM books
WHERE book_id = $1
"""


class GetBookRow(pydantic.BaseModel):
    book_id: int
    author_id: int
    isbn: str
    book_type: models.BookType
    title: str
    year: int
    available: datetime.datetime
    tags: List[str]


UPDATE_BOOK = """-- name: update_book :exec
UPDATE books
SET title = $1, tags = $2
WHERE book_id = $3
"""


UPDATE_BOOK_ISBN = """-- name: update_book_isbn :exec
UPDATE books
SET title = $1, tags = $2, isbn = $4
WHERE book_id = $3
"""


@overload
def books_by_tags(conn: sqlc.Connection, dollar_1: List[str]) -> Iterator[BooksByTagsRow]:
    pass


@overload
def books_by_tags(conn: sqlc.AsyncConnection, dollar_1: List[str]) -> AsyncIterator[BooksByTagsRow]:
    pass


def books_by_tags(conn: sqlc.GenericConnection, dollar_1: List[str]) -> sqlc.IteratorReturn[BooksByTagsRow]:
    return conn.execute_many_model(BooksByTagsRow, BOOKS_BY_TAGS, dollar_1)


@overload
def books_by_title_year(conn: sqlc.Connection, title: str, year: int) -> Iterator[BooksByTitleYearRow]:
    pass


@overload
def books_by_title_year(conn: sqlc.AsyncConnection, title: str, year: int) -> AsyncIterator[BooksByTitleYearRow]:
    pass


def books_by_title_year(conn: sqlc.GenericConnection, title: str, year: int) -> sqlc.IteratorReturn[BooksByTitleYearRow]:
    return conn.execute_many_model(BooksByTitleYearRow, BOOKS_BY_TITLE_YEAR, title, year)


@overload
def create_author(conn: sqlc.Connection, name: str) -> Optional[models.Author]:
    pass


@overload
def create_author(conn: sqlc.AsyncConnection, name: str) -> Awaitable[Optional[models.Author]]:
    pass


def create_author(conn: sqlc.GenericConnection, name: str) -> sqlc.ReturnType[Optional[models.Author]]:
    return conn.execute_one_model(models.Author, CREATE_AUTHOR, name)


@overload
def create_book(conn: sqlc.Connection, arg: CreateBookParams) -> Optional[CreateBookRow]:
    pass


@overload
def create_book(conn: sqlc.AsyncConnection, arg: CreateBookParams) -> Awaitable[Optional[CreateBookRow]]:
    pass


def create_book(conn: sqlc.GenericConnection, arg: CreateBookParams) -> sqlc.ReturnType[Optional[CreateBookRow]]:
    return conn.execute_one_model(CreateBookRow, CREATE_BOOK, arg.author_id, arg.isbn, arg.book_type, arg.title, arg.year, arg.available, arg.tags)


@overload
def delete_book(conn: sqlc.Connection, book_id: int) -> None:
    pass


@overload
def delete_book(conn: sqlc.AsyncConnection, book_id: int) -> Awaitable[None]:
    pass


def delete_book(conn: sqlc.GenericConnection, book_id: int) -> sqlc.ReturnType[None]:
    return conn.execute_none(DELETE_BOOK, book_id)


@overload
def get_author(conn: sqlc.Connection, author_id: int) -> Optional[models.Author]:
    pass


@overload
def get_author(conn: sqlc.AsyncConnection, author_id: int) -> Awaitable[Optional[models.Author]]:
    pass


def get_author(conn: sqlc.GenericConnection, author_id: int) -> sqlc.ReturnType[Optional[models.Author]]:
    return conn.execute_one_model(models.Author, GET_AUTHOR, author_id)


@overload
def get_book(conn: sqlc.Connection, book_id: int) -> Optional[GetBookRow]:
    pass


@overload
def get_book(conn: sqlc.AsyncConnection, book_id: int) -> Awaitable[Optional[GetBookRow]]:
    pass


def get_book(conn: sqlc.GenericConnection, book_id: int) -> sqlc.ReturnType[Optional[GetBookRow]]:
    return conn.execute_one_model(GetBookRow, GET_BOOK, book_id)


@overload
def update_book(conn: sqlc.Connection, title: str, tags: List[str], book_id: int) -> None:
    pass


@overload
def update_book(conn: sqlc.AsyncConnection, title: str, tags: List[str], book_id: int) -> Awaitable[None]:
    pass


def update_book(conn: sqlc.GenericConnection, title: str, tags: List[str], book_id: int) -> sqlc.ReturnType[None]:
    return conn.execute_none(UPDATE_BOOK, title, tags, book_id)


@overload
def update_book_isbn(conn: sqlc.Connection, title: str, tags: List[str], book_id: int, isbn: str) -> None:
    pass


@overload
def update_book_isbn(conn: sqlc.AsyncConnection, title: str, tags: List[str], book_id: int, isbn: str) -> Awaitable[None]:
    pass


def update_book_isbn(conn: sqlc.GenericConnection, title: str, tags: List[str], book_id: int, isbn: str) -> sqlc.ReturnType[None]:
    return conn.execute_none(UPDATE_BOOK_ISBN, title, tags, book_id, isbn)


